Принцип подстановки Лисков (Liskov Substitution Principle) представляет собой некоторое 
руководство по созданию иерархий наследования. Изначальное определение данного принципа, 
которое было дано Барбарой Лисков в 1988 году, выглядело следующим образом
_________________________________________________________________________________________
|Если для каждого объекта o1 типа S существует объект o2 типа T, такой, что для любой	|
|программы P, определенной в терминах T, поведение P не изменяется при замене o2 на o1,	|
|то S является подтипом T.																|
|_______________________________________________________________________________________|

То есть иными словами класс S может считаться подклассом T, если замена объектов T на объекты 
S не приведет к изменению работы программы.

Должна быть возможность вместо базового типа подставить любой его подтип.

Фактически принцип подстановки Лисков помогает четче сформулировать иерархию классов,
определить функционал для базовых и производных классов и избежать возможных проблем при 
применении полиморфизма.

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Проблему, с который связан принцип Лисков, наглядно можно продемонстрировать на примере двух
классов Прямоугольника и Квадрата. Пусть они будут выглядеть следующим образом:
--> ProblemRect.cs

С точки зрения прямоугольника метод TestRectangleArea выглядит нормально, но не с точки зрения
квадрата. Мы ожидаем, что переданный в метод TestRectangleArea объект будет вести себя как
стандартный прямоугольник. Однако квадрат, будучи в иерархии наследования прямоугольником, 
все же ведет себя не как прямоугольник. В итоге программа вывалится в ошибку.

______________________________________________________________________________________________
|Производный класс, который может делать меньше, чем базовый, обычно нельзя подставить вместо  |
|базового, и поэтому он нарушает принцип подстановки Лисков.								   |
|_____________________________________________________________________________________________ |


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Существует несколько типов правил, которые должны быть соблюдены для выполнения принципа
подстановки Лисков. Прежде всего это правила контракта.

Контракт представляет собой некоторый интерфейс базового класса, некоторые соглашения по 
его использованию, которым должен следовать класс-наследник. Контракт задает ряд ограничений 
или правил, и производный класс должен выполнять эти правила:

* Предусловия (Preconditions) не могут быть усилены в подклассе. Другими словами 
  подклассы не должны создавать больше предусловий, чем это определено в базовом классе, 
  для выполнения некоторого поведения
  
  Предусловия представляют набор условий, необходимых для безошибочного выполнения метода.
  Например:

	public virtual void SetCapital(int money)
	{
    	if (money < 0)
        	throw new Exception("Нельзя положить на счет меньше 0");
    	this.Capital = money;
	}

	Здесь условное выражение служит предусловием - без его выполнения не будут выполняться 
	остальные действия, а метод завершится с ошибкой.

	Причем объектом предусловий могут быть только общедоступные свойства или поля класса или
	параметры метода, как в данном случае. Приватное поле не может быть объектом для 
	предусловия, так как оно не может быть установлено из вызывающего кода. 
	Например, в следующем случае условное выражение не является предусловием:

	private bool isValid = false
	public virtual void SetCapital(int money)
	{
		if (isValid == false)
			throw new Exception("Валидация не пройдена");
		this.Capital = money;
	}

	Теперь, допустим, есть два класса: Account (общий счет) и MicroAccount 
	(мини-счет с ограничениями). И второй класс переопределяет метод SetCapital:
	--> ProblemPreconditionsExample.cs

	В этом случае подкласс MicroAccount добавляет дополнительное предусловие, 
	то есть усиливает его, что недопустимо. Поэтому в реальной задаче мы можем столкнуться 
	с проблемой:

	С точки зрения класса Account метод InitializeAccount() вполне является работоспособным. 
	Однако при передаче в него объекта MicroAccount мы столкнемся с ошибкой. В итоге пинцип 
	Лисков будет нарушен.

* Постусловия (Postconditions) не могут быть ослаблены в подклассе. 
  То есть подклассы должны выполнять все постусловия, которые определены в базовом классе.

  Постусловия проверяют состояние возвращаемого объекта на выходе из функции. 
  Например:
  public static float GetMedium(float[] numbers)
  {
  	if (numbers.Length == 0)
    	throw new Exception("длина массива равна нулю");
 
    float result = numbers.Sum() / numbers.Length;
     
    if(result < 0)
        throw new Exception("Результат меньше нуля");
    return result;
  }

  Второе условное выражение здесь является постусловием.
  
  Рассмотрим пример нарушения принципа Лисков при ослаблении постусловия:
  --> ProblemPostconditionsExample.cs

  В качестве постусловия в классе Account используется начисление бонусов в 100 единиц 
  к финальной сумме, если начальная сумма от 1000 и более. В классе MicroAccount это условие 
  не используется.

  Исходя из логики класса Account, в методе CalculateInterest мы ожидаем получить в качестве
  результата числа 1200. Однако логика класса MicroAccount показывает другой результат. В итоге 
  мы приходим к нарушению принципа Лисков, хотя формально мы просто применили стандартные 
  принципы ООП - полиморфизм и наследование.

* Инварианты (Invariants) — все условия базового класса - также должны быть сохранены и в 
  подклассе

  Инварианты - это некоторые условия, которые остаются истинными на протяжении
  всей жизни объекта. Как правило, инварианты передают внутреннее состояние объекта. 
  Например:
  -->InvariantsExample.cs

  Поле age выступает инвариантом. И поскольку его установка возможна только через конструктор 
  или свойство, то в любом случае выполнение предусловия и в конструкторе, и в свойстве 
  гарантирует, что возраст не будет меньше 0. И данное объектоятельство сохранит 
  свою истинность на протяжении всей жизни объекта User.

  Теперь рассмотрим, как здесь может быть нарушен принцип Лисков. Пусть у нас будут следующие
  два класса:
  --> ProblemInvariants.cs

  С точки зрения класса Account поле не может быть меньше 100, и в обоих случаях, 
  где идет присвоение - в конструкторе и свойстве это гарантируется. А вот производный
  класс MicroAccount, переопределяя свойство Capital, этого уже не гарантирует. Поэтому 
  инвариант класса Account нарушается.

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Во всех трех вышеперечисленных случаях проблема решается в общем случае с помощью 
абстрагирования и выделения общего функционала, который уже наследуют классы Account и 
MicroAccount. То есть не один из них наследуется от другого, а оба они наследуются от 
одного общего класса.

Таким образом, принцип подстановки Лисков заставляет задуматься над правильностью построения
иерархий классов и применения полиморфизма, позволяя уйти от ложных иерархий наследования 
и делая всю систему классом более стройной и непротиворечивой.









 















