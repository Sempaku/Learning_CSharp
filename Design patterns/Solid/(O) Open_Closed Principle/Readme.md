Принцип открытости/закрытости (Open/Closed Principle) можно сформулировать так:
Сущности программы должны быть открыты для расширения, но закрыты для изменения.
Суть этого принципа состоит в том, что система должна быть построена таким образом,
что все ее последующие изменения должны быть реализованы с помощью добавления нового 
кода, а не изменения уже существующего.

Рассмотрим простейший пример - класс повара:
--> CookExample.cs
И с помощью метода MakeDinner любой объект данного класса сможет сделать картофельного
пюре

Однако одного умения готовить картофельное пюре для повара вряд ли достаточно.
Хотелось бы, чтобы повар мог приготовить еще что-то. И в этом случае мы подходим к 
необходимости изменения функционала класса, а именно метода MakeDinner. 
Но в соответствии с рассматриваемым нами принципом классы должны быть открыты для 
расширения, но закрыты для изменения. То есть, нам надо сделать класс Cook отрытым для
расширения, но при этом не изменять.

Для решения этой задачи мы можем воспользоваться паттерном Стратегия. В первую очередь нам
надо вынести из класса и инкапсулировать всю ту часть, которая представляет изменяющееся 
поведение. В нашем случае это метод MakeDinner. Однако это не всегда бывает просто сделать.
Возможно, в классе много методов, но на начальном этапе сложно определить, какие из них 
будут изменять свое поведение и как изменять. В этом случае, конечно, надо анализировать
возможные способы изменения и уже на основании анализа делать выводы. То есть, все, что 
подается изменению, выносится из класса и инкапсулируется во вне - во внешних сущностях.

Итак, изменим класс Cook следующим образом
--> NormalCookExample.cs

Теперь приготовление еды абстрагировано в интерфейсе IMeal, а конкретные способы приготовления 
определены в реализациях этого интерфейса. А класс Cook делегирует приготовление еды методу Make
объекта IMeal.

Теперь класс Cook закрыт от изменений, зато мы можем легко расширить его функциональность, 
определив дополнительные реализации интерфейса IMeal.

//___________________________________________________________________________________________

Другим распространенным способом применения принципа открытости/закрытости представляет 
паттерн Шаблонный метод. Переделаем предыдущую задачу с помощью этого паттерна:
--> CookTemplateExample

Теперь абстрактный класс MealBase определяет шаблонный метод Make, отдельные части которого
реализуются классами наследниками.










